<?php

namespace AppBundle\Repository;

use AppBundle\Utils\Util as Util;
use Doctrine\DBAL\Query\QueryBuilder;

/**
 * PersonRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class PersonRepository extends BaseRepository
{

    /**
     * @var array Array of parameters used to filter (set in where clause) the sql that bring list of people grouped by
     *            letters
     */
    private $letterParams = array();

    /**
     * @param string $active Tells if we need to filter on active, non active or none "active" parameter
     * @param array $relatedFilters List of complementary filters to apply
     * @return \Doctrine\DBAL\Driver\Statement
     */
    private function extractPeople($active = 'active', Array $relatedFilters = array()) {
        $conn = $this->getEntityManager()->getConnection();
        $qb = $conn->createQueryBuilder();
        $params = array();

        $qb->select('DISTINCT p.id,
                     p.uid as "samaccountname",
                     p.first_name, 
                     p.last_name, 
                     p.email, 
                     case when coalesce(
                                  (select distinct 
                                     max(
                                       case when pe.exit_date is null then TIMESTAMP \'2100-12-31\' else pe.exit_date end
                                     ) 
                                     over 
                                     (partition by pe.person_ref)
                                   from person_entry pe
                                   where pe.person_ref = p.id
                                  ), TIMESTAMP \'2100-12-31\'   
                               ) >= now() 
                     then \'active\' 
                     else \'inactive\' end as "active"'
        )
            ->from(
                'person',
                'p'
            );

        if ( in_array($active, array('active', 'inactive')) ) {
            $qb->andWhere('case when coalesce(
                                  (select distinct 
                                     max(
                                       case when pe.exit_date is null then TIMESTAMP \'2100-12-31\' else pe.exit_date end
                                     ) 
                                     over 
                                     (partition by pe.person_ref)
                                   from person_entry pe
                                   where pe.person_ref = p.id
                                  ), TIMESTAMP \'2100-12-31\'   
                               ) >= now() 
                     then \'active\' 
                     else \'inactive\' end = ?');
            $params[] = $active;
        }

        $this->composeNamingWhere($qb, $params, $relatedFilters, 'p.first_name || \' \' || p.last_name', 'names');

        $this->composeNumericWhereIn($qb, $params, $relatedFilters, 'p.id', 'ids');

        if ( isset($relatedFilters['teams'] ) ) {
            if ( is_array($relatedFilters['teams']) ) {
                if (count($relatedFilters['teams']) > 0) {
                    $qb->innerJoin(
                        'p',
                        'teams_members',
                        'tm',
                        'p.id = tm.person_ref'
                    );
                    $this->composeNumericWhereIn($qb, $params, $relatedFilters, 'tm.team_ref', 'teams');
                }
            }
        }

        if ( isset($relatedFilters['projects'] ) ) {
            if ( is_array($relatedFilters['projects']) ) {
                if (count($relatedFilters['projects']) > 0) {
                    $qb->innerJoin(
                        'p',
                        'projects_members',
                        'pm',
                        'p.id = pm.person_ref'
                    );
                    $this->composeNumericWhereIn($qb, $params, $relatedFilters, 'pm.project_ref', 'projects');
                }
            }
        }

        if ( isset($relatedFilters['directorates'] ) ) {
            if ( is_array($relatedFilters['directorates']) ) {
                if (count($relatedFilters['directorates']) > 0) {
                    $qb->innerJoin(
                        'p',
                        'working_duty',
                        'wd',
                        'p.id = wd.person_ref'
                    );
                    $this->composeNumericWhereIn($qb, $params, $relatedFilters, 'wd.department_ref', 'directorates');
                }
            }
        }

        if ( isset($relatedFilters['services'] ) ) {
            if ( is_array($relatedFilters['services']) ) {
                if (count($relatedFilters['services']) > 0) {
                    $qb->innerJoin(
                        'p',
                        'working_duty',
                        'wd',
                        'p.id = wd.person_ref'
                    );
                    $this->composeNumericWhereIn($qb, $params, $relatedFilters, 'wd.department_ref', 'services');
                }
            }
        }

        if ( isset($relatedFilters['uids']) ) {
            if ( is_array($relatedFilters['uids']) ) {
                if ( count($relatedFilters['uids']) > 0 ) {
                    $sqlWhere = '(';
                    foreach( $relatedFilters['uids'] as $value ) {
                        $sqlWhere .= '?,';
                        $params[] = $value;
                    }
                    $sqlWhere = rtrim($sqlWhere, ',');
                    $sqlWhere .= ')';
                    if ($sqlWhere !== '()') {
                        $qb->andWhere('p.uid IN ' . $sqlWhere);
                    }
                }
            }
        }

        $qb
            ->setMaxResults(3000)
            ->orderBy('p.last_name');
        $st = $conn->prepare($qb->getSQL());
        $st->execute($params);
        return $st;
    }

    /**
     * @param string $name The person name searched
     * @param bool $exact Tells if search for an exact match or not
     * @param string $locale
     * @return array
     */
    public function searchInName($name, $exact = false, $locale = 'en', $exclusionTable = 'none', $exclusionId = 0) {
        $conn = $this->getEntityManager()->getConnection();
        $qb = $conn->createQueryBuilder();
        $distinct = '';

        if( $exclusionTable === 'teams' || $exclusionTable === 'projects' ) {
            $distinct = 'DISTINCT ';
        }

        $qb->select(
                    $distinct.'p.id as "value",  
                     p.first_name || \' \' || p.last_name as "label",
                     COALESCE(e.exit_date, \'active\') as "active"'
                   )
            ->from(
                'person',
                'p'
            )
            ->leftJoin(
                'p',
                '(
                    select distinct on (person_ref) 
                            person_ref, 
                            entry_date, 
                            CASE 
                              WHEN coalesce(exit_date,\'01/01/2999\'::timestamp) > now() THEN
                                \'active\' 
                              ELSE 
                                \'inactive\' 
                            END as exit_date
                    from person_entry 
                    order by person_ref,entry_date DESC
                 )',
                'e',
                'e.person_ref=p.id'
            );

        $params = array();

        if ( $exclusionTable === 'teams' ) {
            $qb->where(
                'NOT EXISTS (
                    SELECT 1 
                    FROM teams_members 
                    WHERE person_ref = p.id 
                      AND team_ref = ? 
                      AND start_date IS NULL 
                      AND end_date IS NULL
                 )'
            );
            $params[] = $exclusionId;
        }
        elseif ( $exclusionTable === 'projects' ) {
           $qb->where(
                'NOT EXISTS (
                    SELECT 1 
                    FROM projects_members 
                    WHERE person_ref = p.id 
                      AND project_ref = ? 
                      AND start_date IS NULL 
                      AND end_date IS NULL
                 )'
            );
            $params[] = $exclusionId;
        }

        if( $exact === true ) {
            $qb->andwhere('p.first_name || \' \' || p.last_name ilike ?');
            $params[] = $name;
        }
        else {
            foreach(explode(' ', $name) as $term) {
                $term = trim($term);
                if($term == '') continue;
                $term =  Util::unaccent($term);
                $qb->andwhere("translate(p.first_name || ' ' || p.last_name, 'äàáëéèêöôîï','aaaeeeeooii') ilike ?");
                $params[] = '%'.$term.'%';
            }
        }
        $qb
            ->setMaxResults(300)
            ->orderBy('label,value');
        $st = $conn->prepare($qb->getSQL());
        $st->execute($params);
        return  $st->fetchAll();
    }

    /**
     * @param QueryBuilder $qb The Query Builder passed
     * @param string $uidstate The desired uid state(s)
     * @return QueryBuilder The Query Builder filled in
     */
    private function queryBuildWithUidState(QueryBuilder $qb, $uidstate = 'all') {
        $qb->addSelect(
            "
                case 
                    when p.uid is null or p.uid = '' then
                        'person-no-id'
                    when ad.samaccountname is null then
                        'person-wrong-id'
                    else
                        'person-correct-id'
                end as uidstate
            "
        )
            ->leftJoin(
                'p',
                'ad_sync',
                'ad',
                'p.uid=ad.samaccountname'
            )
            ->orderBy(
                "
                    case 
                        when p.uid is null or p.uid = '' then
                            'person-no-id'
                        when ad.samaccountname is null then
                            'person-wrong-id'
                        else
                            'person-correct-id'
                    end
                "
            );
        if ( $uidstate !== 'all' ) {
            $qb->andWhere(
                "
                    case 
                        when p.uid is null or p.uid = '' then
                            'person-no-id'
                        when ad.samaccountname is null then
                            'person-wrong-id'
                        else
                            'person-correct-id'
                    end = :uidstate
                "
            );
            $this->letterParams[':uidstate'] = $uidstate;
        }
        return $qb;
    }

    /**
     * @param QueryBuilder $qb The Query Builder passed
     * @param string $letter The first letter used to get a list filtered by the person name first letter
     * @param string $activeState Filter to get only active/inactive or all people
     * @param int $startFrom The Offset to start from
     * @return QueryBuilder The Query Builder filled in
     */
    public function queryBuildByLetter(QueryBuilder $qb, $letter = '*', $activeState = 'all' ,$startFrom = 0) {
        $qb->select(
            "p.id as \"id\",
             p.first_name as \"firstName\",
             p.last_name as \"lastName\",
             p.email as \"email\",
             p.first_name || ' ' || p.last_name as \"name\",
             COALESCE(e.exit_date, 'active') as \"active\",
             unaccent(
                 regexp_replace(
                    upper(
                        left(
                            p.last_name,
                            1
                         )
                      ),
                      E'\\\d',
                      '#' 
                  )
              ) as \"firstLetter\",
              COUNT(p.id) OVER (PARTITION BY unaccent(regexp_replace(
                upper(
                    left(
                        p.last_name,
                        1
                     )
                  ),
                  E'\\\d',
                  '#' 
              ))) as counting,
              COUNT(p.id) OVER () as \"totalCounting\"
            "
        )
        ->from(
            'person',
            'p'
        )
        ->leftJoin(
            'p',
            '(
            select distinct on (person_ref) 
                    person_ref, 
                    entry_date, 
                    CASE 
                      WHEN coalesce(exit_date,\'01/01/2999\'::timestamp) > now() THEN
                        \'active\' 
                      ELSE 
                        \'inactive\' 
                    END as exit_date
            from person_entry 
            order by person_ref,entry_date DESC
         )',
            'e',
            'e.person_ref=p.id'
        );

        if ( $startFrom !== 0 ) {
            $qb->setFirstResult($startFrom);
        }

        if ( $letter != '*' ) {
            $qb->where(
                "unaccent(regexp_replace(
                    upper(
                        left(
                            p.last_name,
                            1
                         )
                      ),
                      E'\\\d',
                      '#' 
                 )) = :letter"
            );
            $this->letterParams['letter']=$letter;
        }

        if ( in_array($activeState, array('active', 'inactive')) ) {
            $qb->andWhere(
                "COALESCE(e.exit_date, 'active') = :activestate"
            );
            $this->letterParams['activestate']= $activeState;
        }

        $qb
            ->setMaxResults(500);
        return $qb;
    }

    /**
     * @param string $letter The first letter used to get a list filtered by the person name first letter
     * @param int $startFrom The Offset to start from
     * @param string $activeState Filter to get only active/inactive or all people
     * @param string $uidState Complementary parameter to tell if uid state/existence should also appear in the list
     *                         and what to extract
     * @return array
     */
    public function groupsByLetters($letter = '*', $activeState = 'all', $startFrom = 0, $uidState = '') {
        $conn = $this->getEntityManager()->getConnection();
        $qb = $conn->createQueryBuilder();

        $qb = $this->queryBuildByLetter($qb, $letter, $activeState, $startFrom);

        if ( in_array($uidState, array('all', 'person-no-id', 'person-wrong-id', 'person-correct-id')) ) {
            $qb = $this->queryBuildWithUidState($qb, $uidState);
        }
        else {
            $qb->orderBy('"firstLetter",last_name');
        }

        $st = $conn->prepare($qb->getSQL());
        $st->execute($this->letterParams);
        $dbResponse = $st->fetchAll();

        if ( !in_array($uidState, array('all', 'person-no-id', 'person-wrong-id', 'person-correct-id')) ) {
            $response = Util::alphaRange();

            foreach ($dbResponse as $content) {
                $response['*']['count'] = $content['totalCounting'];
                $response[$content['firstLetter']]['count'] = $content['counting'];
                $response['*']['list'][] = $content;
                $response[$content['firstLetter']]['list'][] = $content;
            }

            $response[$letter]['selected'] = 1;
        }
        else {
            $response = Util::alphaRange();
        }

        return $response;
    }

    /**
     * @param string $active Tells if the filter on the active people
     * @param array $relatedFilters List of complementary filter options
     * @return array List of 3000 first found people in database
     */
    public function listAll($active = 'active', Array $relatedFilters = array()) {

        $SQL = $this->extractPeople($active, $relatedFilters);
        return $SQL->fetchAll();

    }
}
